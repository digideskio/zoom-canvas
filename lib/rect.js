// Generated by IcedCoffeeScript 1.6.2c
(function() {
  var rect, vec;



  vec = require('./vec').vec;

  rect = (function() {
    function rect(ll, ur) {
      this.ll = ll || new vec(0, 0);
      this.ur = ur || new vec(0, 0);
    }

    rect.prototype.copy = function() {
      var r;
      return r = new rect(this.ll.copy(), this.ur.copy());
    };

    rect.prototype.is_same = function(r) {
      return this.ll.is_same(r.ll) && this.ur.is_same(r.ur);
    };

    rect.prototype.contain_vec = function(v) {
      var expanded;
      expanded = false;
      if (v.x < this.ll.x) {
        (expanded = true) && (this.ll.x = v.x);
      }
      if (v.x > this.ur.x) {
        (expanded = true) && (this.ur.x = v.x);
      }
      if (v.y < this.ll.y) {
        (expanded = true) && (this.ll.y = v.y);
      }
      if (v.y > this.ur.y) {
        (expanded = true) && (this.ur.y = v.y);
      }
      return expanded;
    };

    rect.prototype.contain_rect = function(r) {
      var expanded;
      expanded = false;
      if (r.ll.x < this.ll.x) {
        (expanded = true) && (this.ll.x = r.ll.x);
      }
      if (r.ur.x > this.ur.x) {
        (expanded = true) && (this.ur.x = r.ur.x);
      }
      if (r.ll.y < this.ll.y) {
        (expanded = true) && (this.ll.y = r.ll.y);
      }
      if (r.ur.y > this.ur.y) {
        (expanded = true) && (this.ur.y = r.ur.y);
      }
      return expanded;
    };

    rect.bounding_vecs = function(vec_array) {
      var i, res, v, _i, _len;
      res = new rect();
      for (i = _i = 0, _len = vec_array.length; _i < _len; i = ++_i) {
        v = vec_array[i];
        if ((i === 0) || v.x < res.ll.x) {
          res.ll.x = v.x;
        }
        if ((i === 0) || v.x > res.ur.x) {
          res.ur.x = v.x;
        }
        if ((i === 0) || v.y < res.ll.y) {
          res.ll.y = v.y;
        }
        if ((i === 0) || v.y > res.ur.y) {
          res.ur.y = v.y;
        }
      }
      return res;
    };

    rect.bounding_rects = function(rects_array) {
      var r, res, _i, _len, _ref;
      if (!rects_array.length) {
        return new rect();
      } else {
        res = rects_array[0].copy();
        _ref = rects_array.slice(1);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          r = _ref[_i];
          res.contain_rect(r);
        }
        return res;
      }
    };

    rect.bounding_circle = function(circle) {
      var c, r;
      c = circle.center;
      r = circle.radius;
      return new rect(new vec(c.x - r, c.y - r), new vec(c.x + r, c.y + r));
    };

    return rect;

  })();

  exports.rect = rect;

}).call(this);
