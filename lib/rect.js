// Generated by IcedCoffeeScript 1.6.2c
(function() {
  var rect, vec;



  vec = require('./vec').vec;

  rect = (function() {
    function rect(ll, ur) {
      this.ll = ll || new vec(0, 0);
      this.ur = ur || new vec(0, 0);
    }

    rect.prototype.copy = function() {
      var r;
      return r = new rect(this.ll.copy(), this.ur.copy());
    };

    rect.bounding_vecs = function(vec_array) {
      var i, res, v, _i, _len;
      res = new rect();
      for (i = _i = 0, _len = vec_array.length; _i < _len; i = ++_i) {
        v = vec_array[i];
        if ((i === 0) || v.x < res.ll.x) {
          res.ll.x = v.x;
        }
        if ((i === 0) || v.x > res.ur.x) {
          res.ur.x = v.x;
        }
        if ((i === 0) || v.y < res.ll.y) {
          res.ll.y = v.y;
        }
        if ((i === 0) || v.y > res.ur.y) {
          res.ur.y = v.y;
        }
      }
      return res;
    };

    rect.bounding_rects = function(rects_array) {
      var r, res, _i, _len, _ref;
      if (!rects_array.length) {
        return new rect();
      } else {
        res = rects_array[0].copy();
        _ref = rects_array.slice(1);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          r = _ref[_i];
          if (r.ll.x < res.ll.x) {
            res.ll.x = r.ll.x;
          }
          if (r.ur.x > res.ur.x) {
            res.ur.x = r.ur.x;
          }
          if (r.ll.y < res.ll.y) {
            res.ll.y = r.ll.y;
          }
          if (r.ur.y > res.ur.y) {
            res.ur.y = r.ur.y;
          }
        }
        return res;
      }
    };

    return rect;

  })();

  exports.rect = rect;

}).call(this);
