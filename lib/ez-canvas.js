// Generated by IcedCoffeeScript 1.6.2c
(function() {
  var draw_code, ezCanvas, rect, vec, zoomCanvas;



  zoomCanvas = require('./zoom-canvas').zoomCanvas;

  rect = require('./rect').rect;

  vec = require('./vec').vec;

  draw_code = exports.draw_code = {
    LINE: 10,
    LINES: 11,
    CIRCLE: 12
  };

  ezCanvas = (function() {
    function ezCanvas(options) {
      /*
        options:
          fill:          fraction of canvas to keep filled; 0.8 means 20% margins
          spring_k:      spring constant for zoom snapping
          spring_damp:   spring dampening for zoom snapping
          step_dt_ms:    ms per step calculation
          canvas:        an actual html5 canvas to follow, so width, height updated automatically
      */

      this.zc = new zoomCanvas(options);
      this.bounds = null;
      this.canvas = options.canvas;
      this.queue = [];
      this.ctx = this.canvas.getContext("2d");
      this.is_affine_applied = false;
    }

    ezCanvas.prototype.line = function(o) {
      return this.queue.push([draw_code.LINE, o]);
    };

    ezCanvas.prototype.lines = function(o) {
      return this.queue.push([draw_code.LINES, o]);
    };

    ezCanvas.prototype.circle = function(o) {
      return this.queue.push([draw_code.CIRCLE, o]);
    };

    ezCanvas.prototype.clear = function() {
      this.clear_canvas();
      this.bounds = null;
      return this.queue = [];
    };

    ezCanvas.prototype.clear_canvas = function() {
      /*
      does not delete its queue
      */

      return this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    };

    ezCanvas.prototype.paint = function(opts) {
      var b, q, _i, _len, _ref, _results;
      opts = opts || {};
      if ((b = opts.bounds)) {
        this.zc.setObjectBounds(b.ll.x, b.ll.y, b.ur.x, b.ur.y);
      } else {
        this.recalc_bounds();
        this.zc.setObjectBounds(this.bounds.ll.x, this.bounds.ll.y, this.bounds.ur.x, this.bounds.ur.y);
      }
      this.zc.step(Date.now());
      _ref = this.queue;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        q = _ref[_i];
        _results.push(this.paint_queued_item(q));
      }
      return _results;
    };

    ezCanvas.prototype.world_pair_to_canvas_pair = function(p) {
      return this.zc.worldPairToCanvasPair(p);
    };

    ezCanvas.prototype.canvas_pair_to_world_pair = function(p) {
      return this.zc.canvasPairToWorldPair(p);
    };

    ezCanvas.prototype.paint_queued_item = function(q_item) {
      var o, qt;
      qt = q_item[0];
      o = q_item[1];
      switch (qt) {
        case draw_code.LINE:
          return this.paint_queued_line(o);
        case draw_code.LINE:
          return this.paint_queued_lines(o);
        case draw_code.CIRCLE:
          return this.paint_queued_circle(o);
        default:
          throw new Error("Dunno how to draw " + qt);
      }
    };

    ezCanvas.prototype.set_ctx_from_cmd = function(o) {
      if (o.lineWidth != null) {
        this.ctx.lineWidth = o.lineWidth;
      }
      if (o.strokeStyle != null) {
        this.ctx.strokeStyle = o.strokeStyle;
      }
      if (o.fillStyle != null) {
        this.ctx.fillStyle = o.fillStyle;
      }
      if (o.lineCap != null) {
        return this.ctx.lineCap = o.lineCap;
      }
    };

    ezCanvas.prototype.paint_queued_line = function(o) {
      this.ctx.save();
      this.ctx.beginPath();
      this.zc.applyToCtx(this.ctx);
      this.set_ctx_from_cmd(o);
      this.ctx.moveTo(o.start[0], o.start[1]);
      this.ctx.lineTo(o.end[0], o.end[1]);
      this.ctx.stroke();
      return this.ctx.restore();
    };

    ezCanvas.prototype.paint_queued_lines = function(o) {
      var p, _i, _len, _ref;
      this.ctx.save();
      this.ctx.beginPath();
      this.apply_affine_to_ctx();
      this.set_ctx_from_cmd(o);
      this.ctx.moveTo(o.points[0][0], o.points[0][1]);
      _ref = o.points.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        this.ctx.lineTo(p[0], p[1]);
      }
      this.ctx.stroke();
      return this.ctx.restore();
    };

    ezCanvas.prototype.paint_queued_circle = function(o) {
      this.ctx.save();
      this.ctx.beginPath();
      this.zc.applyToCtx(this.ctx);
      this.set_ctx_from_cmd(o);
      this.ctx.arc(o.center[0], o.center[1], o.radius, 0, 2 * Math.PI, false);
      if ((o.lineWidth != null) || (o.strokeStyle != null)) {
        this.ctx.stroke();
      }
      if (o.fillStyle != null) {
        this.ctx.fill();
      }
      return this.ctx.restore();
    };

    ezCanvas.prototype.apply_affine_to_ctx = function() {
      if (!this.is_affine_applied) {
        this.is_affine_applied = true;
        return this.zc.applyToCtx(this.ctx);
      }
    };

    ezCanvas.prototype.recalc_bounds = function() {
      var d, q, rects;
      d = Date.now();
      rects = (function() {
        var _i, _len, _ref, _results;
        _ref = this.queue;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          q = _ref[_i];
          if (!q[1].clippable) {
            _results.push(ezCanvas.get_queued_item_bounds(q[0], q[1]));
          }
        }
        return _results;
      }).call(this);
      if (this.bounds != null) {
        rects.push(this.bounds);
      }
      return this.bounds = rect.bounding_rects(rects);
    };

    ezCanvas.get_queued_item_bounds = function(dc, o) {
      switch (dc) {
        case draw_code.LINE:
          return rect.bounding_vecs([new vec(o.start[0], o.start[1]), new vec(o.end[0], o.end[1])]);
        case draw_code.CIRCLE:
          return rect.bounding_circle({
            center: new vec(o.center[0], o.center[1]),
            radius: o.radius
          });
        default:
          throw new Error("Unknown q type: " + dc);
      }
    };

    return ezCanvas;

  })();

  exports.ezCanvas = ezCanvas;

}).call(this);
