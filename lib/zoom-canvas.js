// Generated by IcedCoffeeScript 1.6.2c
(function() {
  var affine, rect, vec, zoomCanvas;



  vec = require('./vec').vec;

  rect = require('./rect').rect;

  affine = require('affine').affine;

  zoomCanvas = (function() {
    function zoomCanvas(options) {
      /*
        options:
          fill:          fraction of canvas to keep filled; 0.8 means 20% margins
          spring_k:      (IF NOT SET, VIEW SNAPS INSTANTLY) spring constant for zoom snapping
          spring_damp:   (IF NOT SET, VIEW SNAPS INSTANTLY) spring dampening for zoom snapping
          step_dt_ms:    ms per step calculation
          ---
          canvas:        an actual html5 canvas to follow, so width, height updated automatically
            - or -
          canvas_width:  width of the "canvas" targeted (say it's not html5 canvas but something else)
          canvas_height: height of the "canvas" targeted
      */

      options = options || {};
      if (!options.canvas && !(options.canvas_width && options.canvas_height)) {
        throw new Error("zoomCanvas expects either a canvas or a canvas_width, canvas_height");
      }
      this.canvas = options.canvas || null;
      this.width = options.canvas_width || this.canvas.width;
      this.height = options.canvas_height || this.canvas.height;
      this.step_dt = options.step_dt_ms != null ? options.step_dt_ms / 1000 : 0.01;
      this.fill = options.fill || 1.0;
      this.spring_k = options.spring_k != null ? options.spring_k : null;
      this.spring_damp = options.spring_damp != null ? options.spring_damp : null;
      this.drawScale = null;
      this.affine = new affine.affine2d();
      this.inv_affine = new affine.affine2d();
      this.lastStep = null;
      this.bounds = {
        target: new rect(),
        actual: new rect(),
        vel: {
          ll: new vec(0, 0),
          ur: new vec(0, 0)
        }
      };
    }

    zoomCanvas.prototype.setObjectBounds = function(xmin, ymin, xmax, ymax) {
      this.bounds.target.ll.x = xmin;
      this.bounds.target.ll.y = ymin;
      this.bounds.target.ur.x = xmax;
      return this.bounds.target.ur.y = ymax;
    };

    zoomCanvas.prototype.getPosRotScale = function() {
      return this.affine.toPosRotScale();
    };

    zoomCanvas.prototype.getPosRotScaleInv = function() {
      return this.inv_affine.toPosRotScale();
    };

    zoomCanvas.prototype.setCtxTransform = function(ctx) {
      /*
      given the context of an html5 canvas,
      this applies the affine to it, so you can
      start drawing shapes in word coordinates
      */

      return this.affine.setCtxTransform(ctx);
    };

    zoomCanvas.prototype.applyToCtx = function(ctx) {
      return this.affine.applyToCtx(ctx);
    };

    zoomCanvas.prototype.step = function(gametime_ms) {
      /*
      pass it your game time, in milliseconds; 
      so that it is smooth jumping, even when a game pauses.
      if you don't care about that or your game is unpausable,
      pass it Date.now()
      */

      var act, count, done, dt, fx0, fx1, fy0, fy1, safety_check, t, tar;
      if (!((this.spring_damp != null) && (this.spring_k != null))) {
        return this.instantZoom();
      } else {
        t = gametime_ms / 1000;
        this.lastStep = this.lastStep || t;
        safety_check = Date.now();
        count = 0;
        done = false;
        while (!done) {
          count++;
          dt = this.step_dt;
          if (this.lastStep < t) {
            this.lastStep += dt;
          } else {
            done = true;
          }
          tar = this.bounds.target;
          act = this.bounds.actual;
          fx0 = (tar.ll.x - act.ll.x) * this.spring_k - this.bounds.vel.ll.x * this.spring_damp;
          fy0 = (tar.ll.y - act.ll.y) * this.spring_k - this.bounds.vel.ll.y * this.spring_damp;
          fx1 = (tar.ur.x - act.ur.x) * this.spring_k - this.bounds.vel.ur.x * this.spring_damp;
          fy1 = (tar.ur.y - act.ur.y) * this.spring_k - this.bounds.vel.ur.y * this.spring_damp;
          this.bounds.vel.ll.x += fx0 * dt;
          this.bounds.vel.ll.y += fy0 * dt;
          this.bounds.vel.ur.x += fx1 * dt;
          this.bounds.vel.ur.y += fy1 * dt;
          act.ll.x += this.bounds.vel.ll.x * dt;
          act.ll.y += this.bounds.vel.ll.y * dt;
          act.ur.x += this.bounds.vel.ur.x * dt;
          act.ur.y += this.bounds.vel.ur.y * dt;
          if ((Date.now() - safety_check) > 10) {
            console.log("Bypassing smoothness for speed reasons after " + count + " steps");
            this.instantZoom();
            break;
          }
        }
        return this._updateAffine();
      }
    };

    zoomCanvas.prototype.worldPairToCanvasPair = function(p) {
      return this.affine.transformPair(p[0], p[1]);
    };

    zoomCanvas.prototype.canvasPairToWorldPair = function(p) {
      return this.inv_affine.transformPair(p[0], p[1]);
    };

    zoomCanvas.prototype.instantZoom = function() {
      this.bounds.vel.ll.zero();
      this.bounds.vel.ur.zero();
      this.bounds.actual = this.bounds.target.copy();
      this.lastStep = null;
      return this._updateAffine();
    };

    zoomCanvas.prototype._updateAffine = function() {
      var act, ctrx, ctry, unit_h, unit_w, x_scale, y_scale;
      if (this.canvas) {
        this.width = this.canvas.width;
        this.height = this.canvas.height;
      }
      act = this.bounds.actual;
      unit_w = act.ur.x - act.ll.x;
      unit_h = act.ur.y - act.ll.y;
      x_scale = this.width / unit_w;
      y_scale = this.height / unit_h;
      this.drawScale = this.fill * Math.min(x_scale, y_scale);
      ctrx = (act.ll.x + act.ur.x) / 2;
      ctry = (act.ll.y + act.ur.y) / 2;
      this.affine = new affine.affine2d();
      this.affine.translate(this.width / 2, this.height / 2);
      this.affine.scale(this.drawScale, -this.drawScale);
      this.affine.translate(-ctrx, -ctry);
      this.inv_affine = new affine.affine2d();
      this.inv_affine.translate(ctrx, ctry);
      this.inv_affine.scale(1 / this.drawScale, -(1 / this.drawScale));
      return this.inv_affine.translate(-this.width / 2, -this.height / 2);
    };

    return zoomCanvas;

  })();

  exports.zoomCanvas = zoomCanvas;

}).call(this);
