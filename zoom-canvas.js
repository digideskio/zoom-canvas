
(function(/*! Stitch !*/) {
  if (!this.require) {
    var modules = {}, cache = {}, require = function(name, root) {
      var path = expand(root, name), module = cache[path], fn;
      if (module) {
        return module.exports;
      } else if (fn = modules[path] || modules[path = expand(path, './index')]) {
        module = {id: path, exports: {}};
        try {
          cache[path] = module;
          fn(module.exports, function(name) {
            return require(name, dirname(path));
          }, module);
          return module.exports;
        } catch (err) {
          delete cache[path];
          throw err;
        }
      } else {
        throw 'module \'' + name + '\' not found';
      }
    }, expand = function(root, name) {
      var results = [], parts, part;
      if (/^\.\.?(\/|$)/.test(name)) {
        parts = [root, name].join('/').split('/');
      } else {
        parts = name.split('/');
      }
      for (var i = 0, length = parts.length; i < length; i++) {
        part = parts[i];
        if (part == '..') {
          results.pop();
        } else if (part != '.' && part != '') {
          results.push(part);
        }
      }
      return results.join('/');
    }, dirname = function(path) {
      return path.split('/').slice(0, -1).join('/');
    };
    this.require = function(name) {
      return require(name, '');
    }
    this.require.define = function(bundle) {
      for (var key in bundle)
        modules[key] = bundle[key];
    };
  }
  return this.require.define;
}).call(this)({"rect": function(exports, require, module) {// Generated by CoffeeScript 1.4.0
(function() {
  var rect, vec;

  vec = require('./vec').vec;

  rect = (function() {

    function rect(ll, ur) {
      this.ll = ll || new vec(0, 0);
      this.ur = ur || new vec(0, 0);
    }

    rect.prototype.copy = function() {
      var r;
      return r = new rect(this.ll.copy(), this.ur.copy());
    };

    return rect;

  })();

  exports.rect = rect;

}).call(this);
}, "vec": function(exports, require, module) {// Generated by CoffeeScript 1.4.0
(function() {
  var vec;

  vec = (function() {

    function vec(x, y) {
      this.x = x;
      this.y = y;
    }

    vec.prototype.zero = function() {
      return this.x = this.y = 0;
    };

    vec.prototype.copy = function() {
      return new vec(this.x, this.y);
    };

    return vec;

  })();

  exports.vec = vec;

}).call(this);
}, "zoom-canvas": function(exports, require, module) {// Generated by CoffeeScript 1.4.0
(function() {
  var affine, rect, vec, zoomCanvas;

  vec = require('./vec').vec;

  rect = require('./rect').rect;

  affine = require('affine').affine;

  zoomCanvas = (function() {

    function zoomCanvas(options) {
      /*
            options:
              fill:          fraction of canvas to keep filled; 0.8 means 20% margins
              spring_k:      spring constant for zoom snapping
              spring_damp:   spring dampeining for zoom snapping
              step_dt_ms:    ms per step calculation
              ---
              canvas:        an actual html5 canvas to follow, so width, height updated automatically
                - or -
              canvas_width:  width of the "canvas" targeted (say it's not html5 canvas but something else)
              canvas_height: height of the "canvas" targeted
      */
      options = options || {};
      if (!options.canvas && !(options.canvas_width && options.canvas_height)) {
        throw new Error("zoomCanvas expects either a canvas or a canvas_width, canvas_height");
      }
      this.canvas = options.canvas || null;
      this.width = options.canvas_width || this.canvas.width;
      this.height = options.canvas_height || this.canvas.height;
      this.step_dt = options.step_dt_ms != null ? options.step_dt_ms / 1000 : 0.01;
      this.fill = options.fill || 1.0;
      this.spring_k = options.spring_k != null ? options.spring_k : 1.0;
      this.spring_damp = options.spring_damp != null ? options.spring_damp : 1.0;
      this.drawScale = null;
      this.affine = new affine.affine2d();
      this.lastStep = null;
      this.bounds = {
        target: new rect(),
        actual: new rect(),
        vel: {
          ll: new vec(0, 0),
          ur: new vec(0, 0)
        }
      };
    }

    zoomCanvas.prototype.setObjectBounds = function(xmin, ymin, xmax, ymax) {
      this.bounds.target.ll.x = xmin;
      this.bounds.target.ll.y = ymin;
      this.bounds.target.ur.x = xmax;
      return this.bounds.target.ur.y = ymax;
    };

    zoomCanvas.prototype.getPosRotScale = function() {
      return this.affine.toPosRotScale();
    };

    zoomCanvas.prototype.setCtxTransform = function(ctx) {
      /*
          given the context of an html5 canvas,
          this applies the affine to it, so you can
          start drawing shapes in word coordinates
      */
      return this.affine.setCtxTransform(ctx);
    };

    zoomCanvas.prototype.applyToCtx = function(ctx) {
      return this.affine.applyToCtx(ctx);
    };

    zoomCanvas.prototype.step = function(gametime_ms) {
      /*
          pass it your game time, in milliseconds; 
          so that it is smooth jumping, even when a game pauses.
          if you don't care about that or your game is unpausable,
          pass it Date.now()
      */

      var act, count, done, dt, fx0, fx1, fy0, fy1, safety_check, t, tar, unit_h, unit_w, x_scale, y_scale;
      t = gametime_ms / 1000;
      this.lastStep = this.lastStep || t;
      safety_check = Date.now();
      count = 0;
      done = false;
      while (!done) {
        count++;
        dt = this.step_dt;
        if (this.lastStep < t) {
          this.lastStep += dt;
        } else {
          done = true;
        }
        tar = this.bounds.target;
        act = this.bounds.actual;
        fx0 = (tar.ll.x - act.ll.x) * this.spring_k - this.bounds.vel.ll.x * this.spring_damp;
        fy0 = (tar.ll.y - act.ll.y) * this.spring_k - this.bounds.vel.ll.y * this.spring_damp;
        fx1 = (tar.ur.x - act.ur.x) * this.spring_k - this.bounds.vel.ur.x * this.spring_damp;
        fy1 = (tar.ur.y - act.ur.y) * this.spring_k - this.bounds.vel.ur.y * this.spring_damp;
        this.bounds.vel.ll.x += fx0 * dt;
        this.bounds.vel.ll.y += fy0 * dt;
        this.bounds.vel.ur.x += fx1 * dt;
        this.bounds.vel.ur.y += fy1 * dt;
        act.ll.x += this.bounds.vel.ll.x * dt;
        act.ll.y += this.bounds.vel.ll.y * dt;
        act.ur.x += this.bounds.vel.ur.x * dt;
        act.ur.y += this.bounds.vel.ur.y * dt;
        if (this.canvas) {
          this.width = this.canvas.width;
          this.height = this.canvas.height;
        }
        unit_w = act.ur.x - act.ll.x;
        unit_h = act.ur.y - act.ll.y;
        x_scale = this.width / unit_w;
        y_scale = this.height / unit_h;
        this.drawScale = this.fill * Math.min(x_scale, y_scale);
        if ((Date.now() - safety_check) > 10) {
          console.log("Bypassing smoothness for speed reasons after " + count + " steps");
          this.instantZoom();
          break;
        }
      }
      return this._updateAffine();
    };

    zoomCanvas.prototype.worldPairToCanvasPair = function(p) {
      return this.affine.transformPair(p[0], p[1]);
    };

    zoomCanvas.prototype.instantZoom = function() {
      this.bounds.vel.ll.zero();
      this.bounds.vel.ur.zero();
      this.bounds.actual = this.bounds.target.copy();
      this.lastStep = null;
      return this._updateAffine();
    };

    zoomCanvas.prototype._updateAffine = function() {
      var ctrx, ctry;
      this.affine = new affine.affine2d();
      this.affine.translate(this.width / 2, this.height / 2);
      this.affine.scale(this.drawScale, -this.drawScale);
      ctrx = (this.bounds.actual.ll.x + this.bounds.actual.ur.x) / 2;
      ctry = (this.bounds.actual.ll.y + this.bounds.actual.ur.y) / 2;
      return this.affine.translate(-ctrx, -ctry);
    };

    return zoomCanvas;

  })();

  exports.zoomCanvas = zoomCanvas;

}).call(this);
}, "affine/affine": function(exports, require, module) {
(function(/*! Stitch !*/) {
  if (!this.require) {
    var modules = {}, cache = {}, require = function(name, root) {
      var path = expand(root, name), module = cache[path], fn;
      if (module) {
        return module.exports;
      } else if (fn = modules[path] || modules[path = expand(path, './index')]) {
        module = {id: path, exports: {}};
        try {
          cache[path] = module;
          fn(module.exports, function(name) {
            return require(name, dirname(path));
          }, module);
          return module.exports;
        } catch (err) {
          delete cache[path];
          throw err;
        }
      } else {
        throw 'module \'' + name + '\' not found';
      }
    }, expand = function(root, name) {
      var results = [], parts, part;
      if (/^\.\.?(\/|$)/.test(name)) {
        parts = [root, name].join('/').split('/');
      } else {
        parts = name.split('/');
      }
      for (var i = 0, length = parts.length; i < length; i++) {
        part = parts[i];
        if (part == '..') {
          results.pop();
        } else if (part != '.' && part != '') {
          results.push(part);
        }
      }
      return results.join('/');
    }, dirname = function(path) {
      return path.split('/').slice(0, -1).join('/');
    };
    this.require = function(name) {
      return require(name, '');
    }
    this.require.define = function(bundle) {
      for (var key in bundle)
        modules[key] = bundle[key];
    };
  }
  return this.require.define;
}).call(this)({"affine": function(exports, require, module) {// Generated by CoffeeScript 1.4.0
(function() {
  var affine2d, flipX, flipY, posRotScale, reflection, reflectionUnit, rotation, scaling, translation,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  exports.compose = function(a1, a2) {
    var res;
    res = a2.copy();
    res.rightComposeWith(a1);
    return res;
  };

  affine2d = (function() {

    function affine2d() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 0) {
        this.m00 = 1;
        this.m01 = 0;
        this.m10 = 0;
        this.m11 = 1;
        this.v0 = 0;
        this.v1 = 0;
      } else if (args.length === 1) {
        this.m00 = args[0].m00;
        this.m01 = args[0].m01;
        this.m10 = args[0].m10;
        this.m11 = args[0].m11;
        this.v0 = args[0].v0;
        this.v1 = args[0].v1;
      } else {
        this.m00 = args[0];
        this.m01 = args[1];
        this.m10 = args[2];
        this.m11 = args[3];
        this.v0 = args[4];
        this.v1 = args[5];
      }
    }

    affine2d.prototype.oneLineSummary = function() {
      return ("M = [" + (this.m00.toPrecision(3))) + (" " + (this.m01.toPrecision(3))) + (" " + (this.m10.toPrecision(3))) + (" " + (this.m11.toPrecision(3)) + "]   V = (") + ("" + (this.v0.toPrecision(3)) + ", ") + (" " + (this.v1.toPrecision(3)) + ")   scale = ") + this.getXScale().toPrecision(3) + " x " + this.getYScale().toPrecision(3);
    };

    affine2d.prototype.copy = function() {
      return new affine2d(this);
    };

    affine2d.prototype.setCtxTransform = function(ctx) {
      /*
          if you have an HTML5 canvas and want to **set**
          its transform to match this affine, use this
      */
      return ctx.setTransform(this.m00, this.m10, this.m01, this.m11, this.v0, this.v1);
    };

    affine2d.prototype.applyToCtx = function(ctx) {
      /*
          if you have an HTML5 canvas and want to **apply**
          this transform to its existing one, use this
      */
      return ctx.transform(this.m00, this.m10, this.m01, this.m11, this.v0, this.v1);
    };

    affine2d.prototype.transformPair = function(v0, v1) {
      var t0, t1;
      t0 = this.m00 * v0 + this.m01 * v1 + this.v0;
      t1 = this.m10 * v0 + this.m11 * v1 + this.v1;
      return [t0, t1];
    };

    affine2d.prototype.transformVec = function(a) {
      var t0, t1;
      t0 = this.m00 * a[0] + this.m01 * a[1] + this.v0;
      t1 = this.m10 * a[0] + this.m11 * a[1] + this.v1;
      a[0] = t0;
      return a[1] = t1;
    };

    affine2d.prototype.rightComposeWith = function(a) {
      /*
          Typically when you have an affine A and you want to 
          perform another affine on it, use this.
          In other words:
            A.rightComposeWith(B)
            performs the composition B(A) and replaces A with the results.
      */

      var t_m00, t_m01, t_m10, t_m11, t_v0, t_v1;
      t_m10 = a.m00 * this.m10 + a.m10 * this.m11;
      t_m11 = a.m01 * this.m10 + a.m11 * this.m11;
      t_v1 = a.v0 * this.m10 + a.v1 * this.m11 + this.v1;
      t_m00 = a.m00 * this.m00 + a.m10 * this.m01;
      t_m01 = a.m01 * this.m00 + a.m11 * this.m01;
      t_v0 = a.v0 * this.m00 + a.v1 * this.m01 + this.v0;
      this.m00 = t_m00;
      this.m01 = t_m01;
      this.m10 = t_m10;
      this.m11 = t_m11;
      this.v0 = t_v0;
      return this.v1 = t_v1;
    };

    affine2d.prototype.leftComposeWith = function(a) {
      /*
          A.leftComposeWith(B)
          performs the composition A(B) and replaces A with the results
      */

      var t_m00, t_m01, t_m10, t_m11, t_v0, t_v1;
      t_m10 = this.m00 * a.m10 + this.m10 * a.m11;
      t_m11 = this.m01 * a.m10 + this.m11 * a.m11;
      t_v1 = this.v0 * a.m10 + this.v1 * a.m11 + a.v1;
      t_m00 = this.m00 * a.m00 + this.m10 * a.m01;
      t_m01 = this.m01 * a.m00 + this.m11 * a.m01;
      t_v0 = this.v0 * a.m00 + this.v1 * a.m01 + a.v0;
      this.m00 = t_m00;
      this.m01 = t_m01;
      this.m10 = t_m10;
      this.m11 = t_m11;
      this.v0 = t_v0;
      return this.v1 = t_v1;
      /*
            a = m00
            b = m10
            d = m01
            e = m11
      */

    };

    affine2d.prototype.deconstruct = function() {
      /*
          returns [xscale, yscale, yshearing, rotation, xtranslation, ytranslation]
          assuming they are applied in that order
      */

      var rotation, xscale, xtranslation, yscale, yshear, ytranslation;
      xscale = Math.sqrt(this.m00 * this.m00 + this.m10 * this.m10);
      yscale = (this.m00 * this.m11 - this.m10 * this.m01) / xscale;
      yshear = (this.m00 * this.m01 + this.m10 * this.m11) / (this.m00 * this.m11 - this.m10 * this.m01);
      rotation = Math.atan2(this.m10, this.m00);
      xtranslation = this.v0;
      ytranslation = this.v1;
      return [xscale, yscale, yshear, rotation, xtranslation, ytranslation];
    };

    affine2d.prototype.toPosRotScale = function() {
      /*    
      this only makes sense if you know your affine only consists
      of a position, rotation, and scaling (i.e., no shearing).
      
      a posRotScale consists of a:
        1. translation
        2. rotation
        3. scaling
      i.e.
        - no shearing
        - they're applied in the above order, which is a natural way of thinking of thinking of object placement
      Note that you can then extract the pos, rot, and scaling from a posRotScale (or modified one)
      by using super's toPosRotScale function
      */

      var xscale;
      xscale = Math.sqrt(this.m00 * this.m00 + this.m10 * this.m10);
      return {
        pos: [this.v0, this.v1],
        rot: Math.atan2(this.m10, this.m00),
        scale: [xscale, (this.m00 * this.m11 - this.m10 * this.m01) / xscale]
      };
    };

    affine2d.prototype.getXCenter = function() {
      return this.v0;
    };

    affine2d.prototype.getYCenter = function() {
      return this.v1;
    };

    affine2d.prototype.scale = function(scale1, scale2) {
      if (!(scale2 != null)) {
        scale2 = scale1;
      }
      return this.rightComposeWith(new scaling(scale1, scale2));
    };

    affine2d.prototype.rotate = function(r) {
      return this.rightComposeWith(new rotation(r));
    };

    affine2d.prototype.translate = function(x, y) {
      return this.rightComposeWith(new translation(x, y));
    };

    affine2d.prototype.flipX = function() {
      return this.rightComposeWith(new flipX());
    };

    affine2d.prototype.flipY = function() {
      return this.rightComposeWith(new flipY());
    };

    affine2d.prototype.reflect = function(angle_or_unit_x, unit_y) {
      if (unit_y != null) {
        return this.rightComposeWith(new reflectionUnit(angle_or_unit_x, unit_y));
      } else {
        return this.rightComposeWith(new reflection(angle_or_unit_x));
      }
    };

    return affine2d;

  })();

  rotation = (function(_super) {

    __extends(rotation, _super);

    function rotation(r) {
      rotation.__super__.constructor.call(this, Math.cos(r), -Math.sin(r), Math.sin(r), Math.cos(r), 0, 0);
    }

    return rotation;

  })(affine2d);

  scaling = (function(_super) {

    __extends(scaling, _super);

    function scaling(sx, sy) {
      scaling.__super__.constructor.call(this, sx, 0, 0, sy, 0, 0);
    }

    return scaling;

  })(affine2d);

  translation = (function(_super) {

    __extends(translation, _super);

    function translation(x, y) {
      translation.__super__.constructor.call(this, 1, 0, 0, 1, x, y);
    }

    return translation;

  })(affine2d);

  reflectionUnit = (function(_super) {

    __extends(reflectionUnit, _super);

    function reflectionUnit(ux, uy) {
      reflectionUnit.__super__.constructor.call(this, 2.0 * ux * ux - 1.0, 2.0 * ux * uy, 2.0 * ux * uy, 2.0 * uy * uy - 1.0, 0.0, 0.0);
    }

    return reflectionUnit;

  })(affine2d);

  reflection = (function(_super) {

    __extends(reflection, _super);

    function reflection(r) {
      reflection.__super__.constructor.call(this, Math.cos(r, Math.sin(r)));
    }

    return reflection;

  })(reflectionUnit);

  flipX = (function(_super) {

    __extends(flipX, _super);

    function flipX() {
      flipX.__super__.constructor.call(this, -1, 0, 0, 1, 0, 0);
    }

    return flipX;

  })(affine2d);

  flipY = (function(_super) {

    __extends(flipY, _super);

    function flipY() {
      flipY.__super__.constructor.call(this, 1, 0, 0, -1, 0, 0);
    }

    return flipY;

  })(affine2d);

  posRotScale = (function(_super) {

    __extends(posRotScale, _super);

    /*
      a posRotScale consists of a:
        1. translation
        2. rotation
        3. scaling
      i.e.
        - no shearing
        - they're applied in the above order, which is a natural way of thinking of thinking of object placement
      Note that you can then extract the pos, rot, and scaling from a posRotScale (or modified one)
      by using super's toPosRotScale function
    */


    function posRotScale(_arg) {
      var pos, rot, scale;
      pos = _arg.pos, rot = _arg.rot, scale = _arg.scale;
      posRotScale.__super__.constructor.call(this);
      this.translate(pos[0], pos[1]);
      this.rotate(rot);
      if ((typeof scale) === "number") {
        this.scale(scale);
      } else if (scale.length === 1) {
        this.scale(scale[0]);
      } else {
        this.scale(scale[0], scale[1]);
      }
    }

    return posRotScale;

  })(affine2d);

  exports.affine2d = affine2d;

  exports.rotation = rotation;

  exports.scaling = scaling;

  exports.translation = translation;

  exports.reflectionUnit = reflectionUnit;

  exports.reflection = reflection;

  exports.flipX = flipX;

  exports.flipY = flipY;

  exports.posRotScale = posRotScale;

}).call(this);
}, "polygon": function(exports, require, module) {// Generated by CoffeeScript 1.4.0
(function() {
  var affine, polygon;

  affine = require('./affine');

  polygon = (function() {

    function polygon(vertices) {
      if (vertices != null) {
        this.vertices = vertices;
      } else {
        this.vertices = [];
      }
    }

    polygon.prototype.copy = function() {
      var new_v, v, _i, _len, _ref;
      new_v = [];
      _ref = this.vertices;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        new_v.push(v.copy());
      }
      return new polygon(new_v);
    };

    polygon.prototype.addVertex = function(v) {
      return this.vertices.push(v);
    };

    polygon.prototype.transform = function(aff) {
      var v, _i, _len, _ref, _results;
      _ref = this.vertices;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _results.push(aff.transformVec(v));
      }
      return _results;
    };

    polygon.prototype.getBoundingRectangle = function() {
      /*
          returns a pair of pairs; 
          for example: [[1,2],[3,5]] 
          means that  1 <= x <= 3
                  and 2 <= y <= 5
          for all points
      */

      var i, v, x, _i, _len, _ref;
      x = null;
      _ref = this.vertices;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        v = _ref[i];
        if (i === 0) {
          x = [[v[0], v[1]], [v[0], v[1]]];
        } else {
          if (v[0] < x[0][0]) {
            x[0][0] = v[0];
          }
          if (v[0] > x[1][0]) {
            x[1][0] = v[0];
          }
          if (v[1] < x[0][1]) {
            x[0][1] = v[1];
          }
          if (v[1] > x[1][1]) {
            x[1][1] = v[1];
          }
        }
      }
      return x;
    };

    return polygon;

  })();

  exports.polygon = polygon;

  exports.factory = {
    unitSquare: function() {
      return new polygon([[0.5, 0.5], [-0.5, 0.5], [-0.5, -0.5], [0.5, -0.5]]);
    },
    unitCircleApprox: function(num) {
      var i, p, radian_increment, radians, _i;
      radian_increment = 2.0 * Math.PI / num;
      radians = 0;
      p = new polygon();
      for (i = _i = 0; 0 <= num ? _i < num : _i > num; i = 0 <= num ? ++_i : --_i) {
        radians += radian_increment;
        p.addVertex([0.5 * Math.cos(radians), 0.5 * Math.sin(radians)]);
      }
      return p;
    }
  };

}).call(this);
}});
}, "affine/index": function(exports, require, module) {// Generated by CoffeeScript 1.4.0
(function() {

  exports.affine = require('./lib/affine');

  exports.polygon = require('./lib/polygon');

}).call(this);
}, "affine/lib/affine": function(exports, require, module) {// Generated by CoffeeScript 1.4.0
(function() {
  var affine2d, flipX, flipY, posRotScale, reflection, reflectionUnit, rotation, scaling, translation,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  exports.compose = function(a1, a2) {
    var res;
    res = a2.copy();
    res.rightComposeWith(a1);
    return res;
  };

  affine2d = (function() {

    function affine2d() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 0) {
        this.m00 = 1;
        this.m01 = 0;
        this.m10 = 0;
        this.m11 = 1;
        this.v0 = 0;
        this.v1 = 0;
      } else if (args.length === 1) {
        this.m00 = args[0].m00;
        this.m01 = args[0].m01;
        this.m10 = args[0].m10;
        this.m11 = args[0].m11;
        this.v0 = args[0].v0;
        this.v1 = args[0].v1;
      } else {
        this.m00 = args[0];
        this.m01 = args[1];
        this.m10 = args[2];
        this.m11 = args[3];
        this.v0 = args[4];
        this.v1 = args[5];
      }
    }

    affine2d.prototype.oneLineSummary = function() {
      return ("M = [" + (this.m00.toPrecision(3))) + (" " + (this.m01.toPrecision(3))) + (" " + (this.m10.toPrecision(3))) + (" " + (this.m11.toPrecision(3)) + "]   V = (") + ("" + (this.v0.toPrecision(3)) + ", ") + (" " + (this.v1.toPrecision(3)) + ")   scale = ") + this.getXScale().toPrecision(3) + " x " + this.getYScale().toPrecision(3);
    };

    affine2d.prototype.copy = function() {
      return new affine2d(this);
    };

    affine2d.prototype.setCtxTransform = function(ctx) {
      /*
          if you have an HTML5 canvas and want to **set**
          its transform to match this affine, use this
      */
      return ctx.setTransform(this.m00, this.m10, this.m01, this.m11, this.v0, this.v1);
    };

    affine2d.prototype.applyToCtx = function(ctx) {
      /*
          if you have an HTML5 canvas and want to **apply**
          this transform to its existing one, use this
      */
      return ctx.transform(this.m00, this.m10, this.m01, this.m11, this.v0, this.v1);
    };

    affine2d.prototype.transformPair = function(v0, v1) {
      var t0, t1;
      t0 = this.m00 * v0 + this.m01 * v1 + this.v0;
      t1 = this.m10 * v0 + this.m11 * v1 + this.v1;
      return [t0, t1];
    };

    affine2d.prototype.transformVec = function(a) {
      var t0, t1;
      t0 = this.m00 * a[0] + this.m01 * a[1] + this.v0;
      t1 = this.m10 * a[0] + this.m11 * a[1] + this.v1;
      a[0] = t0;
      return a[1] = t1;
    };

    affine2d.prototype.rightComposeWith = function(a) {
      /*
          Typically when you have an affine A and you want to 
          perform another affine on it, use this.
          In other words:
            A.rightComposeWith(B)
            performs the composition B(A) and replaces A with the results.
      */

      var t_m00, t_m01, t_m10, t_m11, t_v0, t_v1;
      t_m10 = a.m00 * this.m10 + a.m10 * this.m11;
      t_m11 = a.m01 * this.m10 + a.m11 * this.m11;
      t_v1 = a.v0 * this.m10 + a.v1 * this.m11 + this.v1;
      t_m00 = a.m00 * this.m00 + a.m10 * this.m01;
      t_m01 = a.m01 * this.m00 + a.m11 * this.m01;
      t_v0 = a.v0 * this.m00 + a.v1 * this.m01 + this.v0;
      this.m00 = t_m00;
      this.m01 = t_m01;
      this.m10 = t_m10;
      this.m11 = t_m11;
      this.v0 = t_v0;
      return this.v1 = t_v1;
    };

    affine2d.prototype.leftComposeWith = function(a) {
      /*
          A.leftComposeWith(B)
          performs the composition A(B) and replaces A with the results
      */

      var t_m00, t_m01, t_m10, t_m11, t_v0, t_v1;
      t_m10 = this.m00 * a.m10 + this.m10 * a.m11;
      t_m11 = this.m01 * a.m10 + this.m11 * a.m11;
      t_v1 = this.v0 * a.m10 + this.v1 * a.m11 + a.v1;
      t_m00 = this.m00 * a.m00 + this.m10 * a.m01;
      t_m01 = this.m01 * a.m00 + this.m11 * a.m01;
      t_v0 = this.v0 * a.m00 + this.v1 * a.m01 + a.v0;
      this.m00 = t_m00;
      this.m01 = t_m01;
      this.m10 = t_m10;
      this.m11 = t_m11;
      this.v0 = t_v0;
      return this.v1 = t_v1;
      /*
            a = m00
            b = m10
            d = m01
            e = m11
      */

    };

    affine2d.prototype.deconstruct = function() {
      /*
          returns [xscale, yscale, yshearing, rotation, xtranslation, ytranslation]
          assuming they are applied in that order
      */

      var rotation, xscale, xtranslation, yscale, yshear, ytranslation;
      xscale = Math.sqrt(this.m00 * this.m00 + this.m10 * this.m10);
      yscale = (this.m00 * this.m11 - this.m10 * this.m01) / xscale;
      yshear = (this.m00 * this.m01 + this.m10 * this.m11) / (this.m00 * this.m11 - this.m10 * this.m01);
      rotation = Math.atan2(this.m10, this.m00);
      xtranslation = this.v0;
      ytranslation = this.v1;
      return [xscale, yscale, yshear, rotation, xtranslation, ytranslation];
    };

    affine2d.prototype.toPosRotScale = function() {
      /*    
      this only makes sense if you know your affine only consists
      of a position, rotation, and scaling (i.e., no shearing).
      
      a posRotScale consists of a:
        1. translation
        2. rotation
        3. scaling
      i.e.
        - no shearing
        - they're applied in the above order, which is a natural way of thinking of thinking of object placement
      Note that you can then extract the pos, rot, and scaling from a posRotScale (or modified one)
      by using super's toPosRotScale function
      */

      var xscale;
      xscale = Math.sqrt(this.m00 * this.m00 + this.m10 * this.m10);
      return {
        pos: [this.v0, this.v1],
        rot: Math.atan2(this.m10, this.m00),
        scale: [xscale, (this.m00 * this.m11 - this.m10 * this.m01) / xscale]
      };
    };

    affine2d.prototype.getXCenter = function() {
      return this.v0;
    };

    affine2d.prototype.getYCenter = function() {
      return this.v1;
    };

    affine2d.prototype.scale = function(scale1, scale2) {
      if (!(scale2 != null)) {
        scale2 = scale1;
      }
      return this.rightComposeWith(new scaling(scale1, scale2));
    };

    affine2d.prototype.rotate = function(r) {
      return this.rightComposeWith(new rotation(r));
    };

    affine2d.prototype.translate = function(x, y) {
      return this.rightComposeWith(new translation(x, y));
    };

    affine2d.prototype.flipX = function() {
      return this.rightComposeWith(new flipX());
    };

    affine2d.prototype.flipY = function() {
      return this.rightComposeWith(new flipY());
    };

    affine2d.prototype.reflect = function(angle_or_unit_x, unit_y) {
      if (unit_y != null) {
        return this.rightComposeWith(new reflectionUnit(angle_or_unit_x, unit_y));
      } else {
        return this.rightComposeWith(new reflection(angle_or_unit_x));
      }
    };

    return affine2d;

  })();

  rotation = (function(_super) {

    __extends(rotation, _super);

    function rotation(r) {
      rotation.__super__.constructor.call(this, Math.cos(r), -Math.sin(r), Math.sin(r), Math.cos(r), 0, 0);
    }

    return rotation;

  })(affine2d);

  scaling = (function(_super) {

    __extends(scaling, _super);

    function scaling(sx, sy) {
      scaling.__super__.constructor.call(this, sx, 0, 0, sy, 0, 0);
    }

    return scaling;

  })(affine2d);

  translation = (function(_super) {

    __extends(translation, _super);

    function translation(x, y) {
      translation.__super__.constructor.call(this, 1, 0, 0, 1, x, y);
    }

    return translation;

  })(affine2d);

  reflectionUnit = (function(_super) {

    __extends(reflectionUnit, _super);

    function reflectionUnit(ux, uy) {
      reflectionUnit.__super__.constructor.call(this, 2.0 * ux * ux - 1.0, 2.0 * ux * uy, 2.0 * ux * uy, 2.0 * uy * uy - 1.0, 0.0, 0.0);
    }

    return reflectionUnit;

  })(affine2d);

  reflection = (function(_super) {

    __extends(reflection, _super);

    function reflection(r) {
      reflection.__super__.constructor.call(this, Math.cos(r, Math.sin(r)));
    }

    return reflection;

  })(reflectionUnit);

  flipX = (function(_super) {

    __extends(flipX, _super);

    function flipX() {
      flipX.__super__.constructor.call(this, -1, 0, 0, 1, 0, 0);
    }

    return flipX;

  })(affine2d);

  flipY = (function(_super) {

    __extends(flipY, _super);

    function flipY() {
      flipY.__super__.constructor.call(this, 1, 0, 0, -1, 0, 0);
    }

    return flipY;

  })(affine2d);

  posRotScale = (function(_super) {

    __extends(posRotScale, _super);

    /*
      a posRotScale consists of a:
        1. translation
        2. rotation
        3. scaling
      i.e.
        - no shearing
        - they're applied in the above order, which is a natural way of thinking of thinking of object placement
      Note that you can then extract the pos, rot, and scaling from a posRotScale (or modified one)
      by using super's toPosRotScale function
    */


    function posRotScale(_arg) {
      var pos, rot, scale;
      pos = _arg.pos, rot = _arg.rot, scale = _arg.scale;
      posRotScale.__super__.constructor.call(this);
      this.translate(pos[0], pos[1]);
      this.rotate(rot);
      if ((typeof scale) === "number") {
        this.scale(scale);
      } else if (scale.length === 1) {
        this.scale(scale[0]);
      } else {
        this.scale(scale[0], scale[1]);
      }
    }

    return posRotScale;

  })(affine2d);

  exports.affine2d = affine2d;

  exports.rotation = rotation;

  exports.scaling = scaling;

  exports.translation = translation;

  exports.reflectionUnit = reflectionUnit;

  exports.reflection = reflection;

  exports.flipX = flipX;

  exports.flipY = flipY;

  exports.posRotScale = posRotScale;

}).call(this);
}, "affine/lib/polygon": function(exports, require, module) {// Generated by CoffeeScript 1.4.0
(function() {
  var affine, polygon;

  affine = require('./affine');

  polygon = (function() {

    function polygon(vertices) {
      if (vertices != null) {
        this.vertices = vertices;
      } else {
        this.vertices = [];
      }
    }

    polygon.prototype.copy = function() {
      var new_v, v, _i, _len, _ref;
      new_v = [];
      _ref = this.vertices;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        new_v.push(v.copy());
      }
      return new polygon(new_v);
    };

    polygon.prototype.addVertex = function(v) {
      return this.vertices.push(v);
    };

    polygon.prototype.transform = function(aff) {
      var v, _i, _len, _ref, _results;
      _ref = this.vertices;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _results.push(aff.transformVec(v));
      }
      return _results;
    };

    polygon.prototype.getBoundingRectangle = function() {
      /*
          returns a pair of pairs; 
          for example: [[1,2],[3,5]] 
          means that  1 <= x <= 3
                  and 2 <= y <= 5
          for all points
      */

      var i, v, x, _i, _len, _ref;
      x = null;
      _ref = this.vertices;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        v = _ref[i];
        if (i === 0) {
          x = [[v[0], v[1]], [v[0], v[1]]];
        } else {
          if (v[0] < x[0][0]) {
            x[0][0] = v[0];
          }
          if (v[0] > x[1][0]) {
            x[1][0] = v[0];
          }
          if (v[1] < x[0][1]) {
            x[0][1] = v[1];
          }
          if (v[1] > x[1][1]) {
            x[1][1] = v[1];
          }
        }
      }
      return x;
    };

    return polygon;

  })();

  exports.polygon = polygon;

  exports.factory = {
    unitSquare: function() {
      return new polygon([[0.5, 0.5], [-0.5, 0.5], [-0.5, -0.5], [0.5, -0.5]]);
    },
    unitCircleApprox: function(num) {
      var i, p, radian_increment, radians, _i;
      radian_increment = 2.0 * Math.PI / num;
      radians = 0;
      p = new polygon();
      for (i = _i = 0; 0 <= num ? _i < num : _i > num; i = 0 <= num ? ++_i : --_i) {
        radians += radian_increment;
        p.addVertex([0.5 * Math.cos(radians), 0.5 * Math.sin(radians)]);
      }
      return p;
    }
  };

}).call(this);
}, "affine/src/affine": function(exports, require, module) {(function() {
  var affine2d, flipX, flipY, posRotScale, reflection, reflectionUnit, rotation, scaling, translation,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  exports.compose = function(a1, a2) {
    var res;
    res = a2.copy();
    res.rightComposeWith(a1);
    return res;
  };

  affine2d = (function() {

    function affine2d() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 0) {
        this.m00 = 1;
        this.m01 = 0;
        this.m10 = 0;
        this.m11 = 1;
        this.v0 = 0;
        this.v1 = 0;
      } else if (args.length === 1) {
        this.m00 = args[0].m00;
        this.m01 = args[0].m01;
        this.m10 = args[0].m10;
        this.m11 = args[0].m11;
        this.v0 = args[0].v0;
        this.v1 = args[0].v1;
      } else {
        this.m00 = args[0];
        this.m01 = args[1];
        this.m10 = args[2];
        this.m11 = args[3];
        this.v0 = args[4];
        this.v1 = args[5];
      }
    }

    affine2d.prototype.oneLineSummary = function() {
      return ("M = [" + (this.m00.toPrecision(3))) + (" " + (this.m01.toPrecision(3))) + (" " + (this.m10.toPrecision(3))) + (" " + (this.m11.toPrecision(3)) + "]   V = (") + ("" + (this.v0.toPrecision(3)) + ", ") + (" " + (this.v1.toPrecision(3)) + ")   scale = ") + this.getXScale().toPrecision(3) + " x " + this.getYScale().toPrecision(3);
    };

    affine2d.prototype.copy = function() {
      return new affine2d(this);
    };

    affine2d.prototype.setCtxTransform = function(ctx) {
      /*
          if you have an HTML5 canvas and want to **set**
          its transform to match this affine, use this
      */
      return ctx.setTransform(this.m00, this.m10, this.m01, this.m11, this.v0, this.v1);
    };

    affine2d.prototype.applyToCtx = function(ctx) {
      /*
          if you have an HTML5 canvas and want to **apply**
          this transform to its existing one, use this
      */
      return ctx.transform(this.m00, this.m10, this.m01, this.m11, this.v0, this.v1);
    };

    affine2d.prototype.transformPair = function(v0, v1) {
      var t0, t1;
      t0 = this.m00 * v0 + this.m01 * v1 + this.v0;
      t1 = this.m10 * v0 + this.m11 * v1 + this.v1;
      return [t0, t1];
    };

    affine2d.prototype.transformVec = function(a) {
      var t0, t1;
      t0 = this.m00 * a[0] + this.m01 * a[1] + this.v0;
      t1 = this.m10 * a[0] + this.m11 * a[1] + this.v1;
      a[0] = t0;
      return a[1] = t1;
    };

    affine2d.prototype.rightComposeWith = function(a) {
      /*
          Typically when you have an affine A and you want to 
          perform another affine on it, use this.
          In other words:
            A.rightComposeWith(B)
            performs the composition B(A) and replaces A with the results.
      */

      var t_m00, t_m01, t_m10, t_m11, t_v0, t_v1;
      t_m10 = a.m00 * this.m10 + a.m10 * this.m11;
      t_m11 = a.m01 * this.m10 + a.m11 * this.m11;
      t_v1 = a.v0 * this.m10 + a.v1 * this.m11 + this.v1;
      t_m00 = a.m00 * this.m00 + a.m10 * this.m01;
      t_m01 = a.m01 * this.m00 + a.m11 * this.m01;
      t_v0 = a.v0 * this.m00 + a.v1 * this.m01 + this.v0;
      this.m00 = t_m00;
      this.m01 = t_m01;
      this.m10 = t_m10;
      this.m11 = t_m11;
      this.v0 = t_v0;
      return this.v1 = t_v1;
    };

    affine2d.prototype.leftComposeWith = function(a) {
      /*
          A.leftComposeWith(B)
          performs the composition A(B) and replaces A with the results
      */

      var t_m00, t_m01, t_m10, t_m11, t_v0, t_v1;
      t_m10 = this.m00 * a.m10 + this.m10 * a.m11;
      t_m11 = this.m01 * a.m10 + this.m11 * a.m11;
      t_v1 = this.v0 * a.m10 + this.v1 * a.m11 + a.v1;
      t_m00 = this.m00 * a.m00 + this.m10 * a.m01;
      t_m01 = this.m01 * a.m00 + this.m11 * a.m01;
      t_v0 = this.v0 * a.m00 + this.v1 * a.m01 + a.v0;
      this.m00 = t_m00;
      this.m01 = t_m01;
      this.m10 = t_m10;
      this.m11 = t_m11;
      this.v0 = t_v0;
      return this.v1 = t_v1;
      /*
            a = m00
            b = m10
            d = m01
            e = m11
      */

    };

    affine2d.prototype.deconstruct = function() {
      /*
          returns [xscale, yscale, yshearing, rotation, xtranslation, ytranslation]
          assuming they are applied in that order
      */

      var rotation, xscale, xtranslation, yscale, yshear, ytranslation;
      xscale = Math.sqrt(this.m00 * this.m00 + this.m10 * this.m10);
      yscale = (this.m00 * this.m11 - this.m10 * this.m01) / xscale;
      yshear = (this.m00 * this.m01 + this.m10 * this.m11) / (this.m00 * this.m11 - this.m10 * this.m01);
      rotation = Math.atan2(this.m10, this.m00);
      xtranslation = this.v0;
      ytranslation = this.v1;
      return [xscale, yscale, yshear, rotation, xtranslation, ytranslation];
    };

    affine2d.prototype.toPosRotScale = function() {
      /*    
      this only makes sense if you know your affine only consists
      of a position, rotation, and scaling (i.e., no shearing).
      
      a posRotScale consists of a:
        1. translation
        2. rotation
        3. scaling
      i.e.
        - no shearing
        - they're applied in the above order, which is a natural way of thinking of thinking of object placement
      Note that you can then extract the pos, rot, and scaling from a posRotScale (or modified one)
      by using super's toPosRotScale function
      */

      var xscale;
      xscale = Math.sqrt(this.m00 * this.m00 + this.m10 * this.m10);
      return {
        pos: [this.v0, this.v1],
        rot: Math.atan2(this.m10, this.m00),
        scale: [xscale, (this.m00 * this.m11 - this.m10 * this.m01) / xscale]
      };
    };

    affine2d.prototype.getXCenter = function() {
      return this.v0;
    };

    affine2d.prototype.getYCenter = function() {
      return this.v1;
    };

    affine2d.prototype.scale = function(scale1, scale2) {
      if (!(scale2 != null)) {
        scale2 = scale1;
      }
      return this.rightComposeWith(new scaling(scale1, scale2));
    };

    affine2d.prototype.rotate = function(r) {
      return this.rightComposeWith(new rotation(r));
    };

    affine2d.prototype.translate = function(x, y) {
      return this.rightComposeWith(new translation(x, y));
    };

    affine2d.prototype.flipX = function() {
      return this.rightComposeWith(new flipX());
    };

    affine2d.prototype.flipY = function() {
      return this.rightComposeWith(new flipY());
    };

    affine2d.prototype.reflect = function(angle_or_unit_x, unit_y) {
      if (unit_y != null) {
        return this.rightComposeWith(new reflectionUnit(angle_or_unit_x, unit_y));
      } else {
        return this.rightComposeWith(new reflection(angle_or_unit_x));
      }
    };

    return affine2d;

  })();

  rotation = (function(_super) {

    __extends(rotation, _super);

    function rotation(r) {
      rotation.__super__.constructor.call(this, Math.cos(r), -Math.sin(r), Math.sin(r), Math.cos(r), 0, 0);
    }

    return rotation;

  })(affine2d);

  scaling = (function(_super) {

    __extends(scaling, _super);

    function scaling(sx, sy) {
      scaling.__super__.constructor.call(this, sx, 0, 0, sy, 0, 0);
    }

    return scaling;

  })(affine2d);

  translation = (function(_super) {

    __extends(translation, _super);

    function translation(x, y) {
      translation.__super__.constructor.call(this, 1, 0, 0, 1, x, y);
    }

    return translation;

  })(affine2d);

  reflectionUnit = (function(_super) {

    __extends(reflectionUnit, _super);

    function reflectionUnit(ux, uy) {
      reflectionUnit.__super__.constructor.call(this, 2.0 * ux * ux - 1.0, 2.0 * ux * uy, 2.0 * ux * uy, 2.0 * uy * uy - 1.0, 0.0, 0.0);
    }

    return reflectionUnit;

  })(affine2d);

  reflection = (function(_super) {

    __extends(reflection, _super);

    function reflection(r) {
      reflection.__super__.constructor.call(this, Math.cos(r, Math.sin(r)));
    }

    return reflection;

  })(reflectionUnit);

  flipX = (function(_super) {

    __extends(flipX, _super);

    function flipX() {
      flipX.__super__.constructor.call(this, -1, 0, 0, 1, 0, 0);
    }

    return flipX;

  })(affine2d);

  flipY = (function(_super) {

    __extends(flipY, _super);

    function flipY() {
      flipY.__super__.constructor.call(this, 1, 0, 0, -1, 0, 0);
    }

    return flipY;

  })(affine2d);

  posRotScale = (function(_super) {

    __extends(posRotScale, _super);

    /*
      a posRotScale consists of a:
        1. translation
        2. rotation
        3. scaling
      i.e.
        - no shearing
        - they're applied in the above order, which is a natural way of thinking of thinking of object placement
      Note that you can then extract the pos, rot, and scaling from a posRotScale (or modified one)
      by using super's toPosRotScale function
    */


    function posRotScale(_arg) {
      var pos, rot, scale;
      pos = _arg.pos, rot = _arg.rot, scale = _arg.scale;
      posRotScale.__super__.constructor.call(this);
      this.translate(pos[0], pos[1]);
      this.rotate(rot);
      if ((typeof scale) === "number") {
        this.scale(scale);
      } else if (scale.length === 1) {
        this.scale(scale[0]);
      } else {
        this.scale(scale[0], scale[1]);
      }
    }

    return posRotScale;

  })(affine2d);

  exports.affine2d = affine2d;

  exports.rotation = rotation;

  exports.scaling = scaling;

  exports.translation = translation;

  exports.reflectionUnit = reflectionUnit;

  exports.reflection = reflection;

  exports.flipX = flipX;

  exports.flipY = flipY;

  exports.posRotScale = posRotScale;

}).call(this);
}, "affine/src/polygon": function(exports, require, module) {(function() {
  var affine, polygon;

  affine = require('./affine');

  polygon = (function() {

    function polygon(vertices) {
      if (vertices != null) {
        this.vertices = vertices;
      } else {
        this.vertices = [];
      }
    }

    polygon.prototype.copy = function() {
      var new_v, v, _i, _len, _ref;
      new_v = [];
      _ref = this.vertices;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        new_v.push(v.copy());
      }
      return new polygon(new_v);
    };

    polygon.prototype.addVertex = function(v) {
      return this.vertices.push(v);
    };

    polygon.prototype.transform = function(aff) {
      var v, _i, _len, _ref, _results;
      _ref = this.vertices;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _results.push(aff.transformVec(v));
      }
      return _results;
    };

    polygon.prototype.getBoundingRectangle = function() {
      /*
          returns a pair of pairs; 
          for example: [[1,2],[3,5]] 
          means that  1 <= x <= 3
                  and 2 <= y <= 5
          for all points
      */

      var i, v, x, _i, _len, _ref;
      x = null;
      _ref = this.vertices;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        v = _ref[i];
        if (i === 0) {
          x = [[v[0], v[1]], [v[0], v[1]]];
        } else {
          if (v[0] < x[0][0]) {
            x[0][0] = v[0];
          }
          if (v[0] > x[1][0]) {
            x[1][0] = v[0];
          }
          if (v[1] < x[0][1]) {
            x[0][1] = v[1];
          }
          if (v[1] > x[1][1]) {
            x[1][1] = v[1];
          }
        }
      }
      return x;
    };

    return polygon;

  })();

  exports.polygon = polygon;

  exports.factory = {
    unitSquare: function() {
      return new polygon([[0.5, 0.5], [-0.5, 0.5], [-0.5, -0.5], [0.5, -0.5]]);
    },
    unitCircleApprox: function(num) {
      var i, p, radian_increment, radians, _i;
      radian_increment = 2.0 * Math.PI / num;
      radians = 0;
      p = new polygon();
      for (i = _i = 0; 0 <= num ? _i < num : _i > num; i = 0 <= num ? ++_i : --_i) {
        radians += radian_increment;
        p.addVertex([0.5 * Math.cos(radians), 0.5 * Math.sin(radians)]);
      }
      return p;
    }
  };

}).call(this);
}, "affine/test/node-test": function(exports, require, module) {(function() {
  var affine, do_nothing, go_big, go_small, polygon, rot_left, rot_right, square;

  affine = require('../src/affine');

  polygon = require('../src/polygon');

  rot_left = new affine.rotation(Math.PI / 4);

  rot_right = new affine.rotation(-Math.PI / 4);

  go_big = new affine.scaling(2, 4);

  go_small = new affine.scaling(0.5, 0.25);

  do_nothing = rot_left.copy();

  do_nothing.rightComposeWith(rot_right);

  do_nothing.rightComposeWith(go_big);

  do_nothing.rightComposeWith(go_small);

  square = polygon.factory.unitSquare();

  console.log("1. Square before\n--------------");

  console.log(square);

  console.log("2. Square after \n--------------");

  square.transform(do_nothing);

  console.log(square);

}).call(this);
}});
